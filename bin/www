#!/usr/bin/env node

/**
 * Module dependencies.
 */

"use strict";

const app = require('../app');
const http = require('http');
const util = require('util');
const assert = require("assert");
const logger = require('./logger');
const log = logger().getLogger('wwww');
const infrastructure = require("./infrastructure");
const helpers = require("./helpers");
const ctshistory = require("./ctshistory");
const opstore = require('./opstore.js');  // opstore: short for Operational Store, in this case Redis
const ctsparser = require("./ctsparser")(handleCTSEvent);


//Get port from environment and store in Express.
const port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

//Create HTTP server.
const server = http.createServer(app);
const io = require('socket.io')(server);
const ctslivestatus = require("./ctslivestatus")(io);
const cmd = require ("./commands")(io);
const apcrealtime = require("./apcrealtime")(io);

let numberOfUsers = 0;
const realtime = "realtime";


// "middleware for socketio. If this function return "next()" connection is established. if it returns next(new Error...) connection is refused
let socketAuth = function socketAuth(socket, next) {
    //console.log("socket: " + socket + " next: " + next);
    //redisStore.set(keyMgr(opStore.users), socket.id, function (err, reply) {
    //    //console.log("User authorising. Storing socket.id: " + err + " " + reply);
    //});
    return next();
    //return next(new Error('Nothing Defined'));
};
io.use(socketAuth);

infrastructure.readMetroInfrastructure();

// send server time to all clients every second
const emitTime = setInterval(function () {
    io.to(realtime).emit("timetick", Date.now());
}, 1000 * 1);  // Send server time to all connected clients every second
/*
opstore.on("err_flushall", function(msg) {
    console.log("error: " + msg);
});
opstore.on("flushall", function(msg) {
    console.log("success on opstore: " + msg);
});
*/
//
// CLIENT COMMUNICATIONS
//
// Note: socket.emit => send data to the specific client that sent data to or connected to server _only
// io.emit => send data to _all connected clients

io.on('connection', function (socket) {
    //console.log('a user connected');
    socket.emit("id", socket.id);
    socket.emit("ip", socket.request.connection.remoteAddress);
    socket.join(realtime);
    socket.room = realtime; // NB: do not confuse with socket.rooms which is property of socket.io
    socket.mode = realtime;

    ++numberOfUsers;

    socket.emit("initinfrastructure", {
        "stations": infrastructure.getStationObject(),
        "berths": infrastructure.getBerthTable(),
        "trackswitches": infrastructure.getTrackSwitchTable(),
        "endberths": infrastructure.getEndBerthTable(),
        "tracks": infrastructure.getTracksObject(),
        "trains": apcrealtime.getAPCObject() // note: this is only trains where we know their serial number (i.e. "OwnModuleID")
    });

    if (apcrealtime.hasPassengers) {
        socket.emit("pax", apcrealtime.getPassengerTable);
    }
    if (apcrealtime.hasSumPerLine()) {
        socket.emit("LineAggregate", apcrealtime.getSumPerLineTable());
    }
    if (apcrealtime.hasSumPerStation()) {
        socket.emit("StationAggregate", apcrealtime.getSumPerStationTable());
    }
    if (apcrealtime.hasSumPerOwnModule()) {
        socket.emit("OwnModuleAggregate", apcrealtime.getSumPerOwnModuleTable());
    }
    socket.emit('LastPaxUpdateTime', apcrealtime.getLastPaxUpdateTimeUnix());

    socket.on('disconnect', function () {
        //console.log('user disconnected');
        --numberOfUsers;
    });

    //todo: add proper command interpreter, add support for help, enter "admin" mode? float on map?
    socket.on('chat message', function (msg) {
        let cmdArray = msg.split(" ");

        if (!msg) {
            return; // received empty string
        }
        cmdArray[0] = cmdArray[0].toLowerCase();

        io.emit('chat message', msg);
        cmd.parseAndDo (cmdArray, socket);
    }); // chat message

    socket.on("client error", function (msg) {
        log.error("Client Error: " + msg);
    });

    // station, berth, trackswitch not implemented in clients for now
    socket.on("stationsrequest", function (msg, fn) { // msg; {}
        fn(infrastructure.getStationObject());
    }); //stationrequest

    socket.on("berthsrequest", function (msg, fn) { // msg; { }
        fn(infrastructure.getBerthTable());
    }); //berthrequest

    socket.on("trackswitchesrequest", function (msg, fn) { // msg; { }
        fn(infrastructure.getTrackSwitchTable());
    }); //trackswitchrequest


    // send the "tail" of a train, i.e. list of latest berth-passings
    socket.on("tailrequest", function (msg, fn) { // msg; {trainNo: id, count: noOfBerthsToSend }
        fn(ctslivestatus.getTail(msg.trainNo, msg.noOfBerths));
    }); // tailrequest

    // send "tail" of all trains, i.e. array of lists of berth-passings
    socket.on("alltailsrequest", function (msg, fn) { // msg; {trainNo: id, maxBerths: max no Of Berths To Send for one train}
        fn(ctslivestatus.getAllTails(msg.maxBerths));
    }); // alltailsrequest

    socket.on("ghostrequest", function (msg, fn) { // msg; { }
        // send data
        fn(ctslivestatus.getGhosts());
    }); //ghostrequest
}); // socket.io

//
// END CLIENT-COMMUNICATION
//

function handleRealtime (socket, cmdArray) {
    if (!socket.joined) {
        socket.emit("help", {realtime: cmdDictionary.realtime});
        return;
    }
    let toSocketID = socket.room;
    let tmpSocket = io.sockets.connected[toSocketID];
    if (!toSocketID|| !tmpSocket) {
        socket.emit("chat message", "internal error - communications ID not found (socket.room) " + toSocketID);
        return;
    }
    if (tmpSocket.room === realtime) {
        socket.emit("chat message", "Already processing realtime");
        return;
    }

    if (tmpSocket.mode === "history") { // playBack is ongoing
        socket.emit("chat message", "Cancel ongoing playback/operation first, then issue new realtime command.");
        return;
    }
    if (tmpSocket.mode !== "ready") {
        console.log("received realtime. tmp.socket.mode: " + tmpSocket.mode);
    }

    if (tmpSocket.room && tmpSocket.room !== realtime) {  // remember: tmpSocket is the socket of the map-client, not current (cmd) client
        tmpSocket.leave(tmpSocket.room);
    }

    tmpSocket.join(realtime);
    tmpSocket.room = realtime;
    tmpSocket.mode = realtime;
    socket.to(toSocketID).emit(realtime, "start");
} // handleRealtime ()

//
// BACK END COMMUNICATIONS
// Subscribe to operational data store (i.e Redis) topics

opstore.subscribe("pax");
opstore.subscribe("LineAggregate");
opstore.subscribe("StationAggregate");
opstore.subscribe("OwnModuleAggregate");
opstore.subscribe("Log");
opstore.subscribe("Error");

opstore.subscribe("cts");

opstore.subscribe("cts_ghost_train");
opstore.subscribe("cts_special_code");
opstore.subscribe("cts_trainno_change");
opstore.subscribe("cts_event_missing_to");
opstore.subscribe("cts_event");


opstore.on("error", function (err) {
    console.log("Error " + err);
});

// Start Redis communication
opstore.on("subscribe", function (channel, message ) {
    io.emit("chat message", "succesful subscribe to Redis " + channel + "  " + message);
    log.info("succesful subscribe to Redis: " + channel + " " + count);
});


// Handle data from Redis
opstore.on("message", function (channel, msg) {
    let msgObject = JSON.parse(msg);

    //io.to(room).emit("cts_train_jump", msgObject);
    //io.to(room).emit("cts_trainnumber_first_time", msgObject); // notify the client

    // emit all data we get as a separate topic, except for log-data
    if (channel !== "Log") {
        io.emit("data", msg);
    }

    if (channel === "cts") {
        msgObject = ctsparser.parseAndSendCTS(msgObject); // parses the event and calles opstore.saveCTS which in turn publish one of the events below
        handleCTSEvent(msgObject);
    }
    else if (channel === "pax") {
        apcrealtime.parsePassengerData(realtime, channel, msgObject);
    }
    else if (channel === "LineAggregate") {
        apcrealtime.parseSumPerLine(realtime, channel, msgObject);
    }
    else if (channel === "StationAggregate") {
        apcrealtime.parseSumPerStation(realtime, channel, msgObject);
    }
    else if (channel === "OwnModuleAggregate") { // todo: add room to all of these: realtime
        apcrealtime.parseSumPerOwnModule(realtime, channel, msgObject);
    }
    else if (channel === "Log" || channel === "Error") {
        io.emit("Log", channel + ": " + msg)
    }
    else {
        log.error ("opstore.On. Unknown channel: " + channel + " Message: " + msg);
    }
});

function handleCTSEvent (msgObject) {
    if (!msgObject) {
        log.error("opstore.on-cts. Invalid msgObject");
        return;
    }
    saveCTSEvent(msgObject);
    ctslivestatus.updateCTSLiveObject((msgObject));
    io.to(realtime).emit("cts_" + msgObject.values.event, [msgObject]);
} // handleCTSEvent()

function saveCTSEvent (msgObject) {
    assert (typeof msgObject === "object");

    opstore.saveCTSEvent (msgObject, function (err, success) {
        if (err) {
            log.error("saveCTSEvent. saveCTSEvent error: " + err);
        }
    });
} // saveNormalCTSEvent()

// todo: REDIS clean up is not working properly, i.e. if web app terminate and restart, the number of redis connections may increase?
process.on('exit', function () {
    console.log('About to exit.');
    //todo: check if subscription is active and if connection is open
    opstore.unsubscribe();
    opstore.end();
});
process.on('SIGINT', function () {
    console.log('Got CTRL-D');
    //todo: check if subscription is active and if connection is open
    opstore.unsubscribe();
    opstore.end();
    process.exit(2);
});
process.on('uncaughtException', function (e) {
    console.log('Uncaught Exception...');
    console.log(e.stack);
    //todo: check if subscription is active and if connection is open
    opstore.unsubscribe();
    opstore.end();
    process.exit(99);
});

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    const port = parseInt(val, 10);

    if (helpers.MyIsNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    const bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    const addr = server.address();
    const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
    //debug('Listening on ' + bind);
}
