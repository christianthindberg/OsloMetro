#!/usr/bin/env node

/**
 * Module dependencies.
 */

"use strict";

const app = require('../app');
const http = require('http');
const util = require('util');
const logger = require('./logger');
const log = logger().getLogger('wwww');
const infrastructure = require("./infrastructure");
const helpers = require("./helpers");
const ctshistory = require("./ctshistory");
const opstore = require('./opstore.js');  // opstore: short for Operational Store, in this case Redis

//Get port from environment and store in Express.
const port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

//Create HTTP server.
const server = http.createServer(app);
const io = require('socket.io')(server);

const cmd = require ("./commands")(io);
const ctsrealtime = require("./ctsrealtime")(io);
const apcrealtime = require("./apcrealtime")(io);

let numberOfUsers = 0;


// "middleware for socketio. If this function return "next()" connection is established. if it returns next(new Error...) connection is refused
let socketAuth = function socketAuth(socket, next) {
    //console.log("socket: " + socket + " next: " + next);
    //redisStore.set(keyMgr(opStore.users), socket.id, function (err, reply) {
    //    //console.log("User authorising. Storing socket.id: " + err + " " + reply);
    //});
    return next();
    //return next(new Error('Nothing Defined'));
};
io.use(socketAuth);

infrastructure.readMetroInfrastructure();

// send server time to all clients every second
const emitTime = setInterval(function () {
    io.to("realtime").emit("timetick", Date.now());
}, 1000 * 1);  // Send server time to all connected clients every second
/*
opstore.on("err_flushall", function(msg) {
    console.log("error: " + msg);
});
opstore.on("flushall", function(msg) {
    console.log("success on opstore: " + msg);
});
*/
//
// CLIENT COMMUNICATIONS
//
// Note: socket.emit => send data to the specific client that sent data to or connected to server _only
// io.emit => send data to _all connected clients

io.on('connection', function (socket) {
    //console.log('a user connected');
    socket.emit("id", socket.id);
    socket.emit("ip", socket.request.connection.remoteAddress);
    socket.join("realtime");
    socket.room = "realtime"; // NB: do not confuse with socket.rooms which is property of socket.io
    socket.mode = "realtime";

    ++numberOfUsers;

    socket.emit("initinfrastructure", {
        "stations": infrastructure.getStationObject(),
        "berths": infrastructure.getBerthTable(),
        "trackswitches": infrastructure.getTrackSwitchTable(),
        "endberths": infrastructure.getEndBerthTable(),
        "tracks": infrastructure.getTracksObject(),
        "trains": apcrealtime.getAPCObject() // note: this is only trains where we know their serial number (i.e. "OwnModuleID")
    });

    if (apcrealtime.hasPassengers) {
        socket.emit("pax", apcrealtime.getPassengerTable);
    }
    if (apcrealtime.hasSumPerLine()) {
        socket.emit("LineAggregate", apcrealtime.getSumPerLineTable());
    }
    if (apcrealtime.hasSumPerStation()) {
        socket.emit("StationAggregate", apcrealtime.getSumPerStationTable());
    }
    if (apcrealtime.hasSumPerOwnModule()) {
        socket.emit("OwnModuleAggregate", apcrealtime.getSumPerOwnModuleTable());
    }
    socket.emit('LastPaxUpdateTime', apcrealtime.getLastPaxUpdateTimeUnix());

    socket.on('disconnect', function () {
        //console.log('user disconnected');
        --numberOfUsers;
    });

    //todo: add proper command interpreter, add support for help, enter "admin" mode? float on map?
    socket.on('chat message', function (msg) {
        io.emit('chat message', msg);
        let cmdArray = msg.split(" ");

        if (!msg) {
            return; // received empty string
        }
        cmdArray[0] = cmdArray[0].toLowerCase();

        switch (cmdArray[0]) {
            case "?":
            case "help":
                cmd.help(cmdArray, socket);
                break;
            case "sub":
                opstore.testSubscribe();
                break;
            case "flushall":
                cmd.flushAll(cmdArray, socket);
                break;
            case "master":
               cmd.master(cmdArray,socket);
                break;
            case "cts":
                cmd.getCTSEvent(cmdArray, socket);
                break;
            case "eventid":
                cmd.getCTSLastEventID (cmdArray, socket);
                break;
            case "join":
                cmd.join (cmdArray, socket);
                break;
            case "unjoin":
                // not implemented
                break;
            case "aggregate":
                ctshistory.handleAggregateSend (socket, cmdArray);
                break;
            case "history":
                ctshistory.handleHistoryPlayback (socket, cmdArray);
                break;
            case "cancel":
                ctshistory.handlePlaybackCancel(socket, cmdArray);
                break;
            case "realtime":
                handleRealtime(socket, cmdArray);
                break;
            case "trains":
                cmd.getTrains (cmdArray, socket);
                break;
            case "range":
                cmd.getFirstAndLastCTSEvent (cmdArray, socket);
                break;
            case "info":
                socket.emit('chat message', "Redis says: " + JSON.stringify(opstore.getStoreInfo(), undefined, 2));
                break;
            case "max":
                cmd.setMaxCTSEvents (cmdArray, socket);
                break;
            case "count":
                cmd.countCTSEvents (cmdArray, socket);
                break;
            case "sockets":
                cmd.getSockets (cmdArray, socket);
                break;
            case "berth":
                cmd.getOkBerths (cmdArray, socket);  // send berths from which we have received signal to joined client for visualization
                break;
            case "blink":
                cmd.setBlinkAlarms (cmdArray, socket);
                break;
            case "destination":
                cmd.setDestination (cmdArray, socket);
                break;
            case "ghost":
                cmd.generateTestGhosts (cmdArray, socket);
                break;
        }
    }); // chat message

    // station, berth, trackswitch not implemented in clients for now
    socket.on("stationsrequest", function (msg, fn) { // msg; {}
        fn(infrastructure.getStationObject());
    }); //stationrequest

    socket.on("berthsrequest", function (msg, fn) { // msg; { }
        fn(infrastructure.getBerthTable());
    }); //berthrequest

    socket.on("trackswitchesrequest", function (msg, fn) { // msg; { }
        fn(infrastructure.getTrackSwitchTable());
    }); //trackswitchrequest


    // send the "tail" of a train, i.e. list of latest berth-passings
    socket.on("tailrequest", function (msg, fn) { // msg; {trainNo: id, count: noOfBerthsToSend }
        fn(ctsrealtime.getTail(msg.trainNo, msg.noOfBerths));
    }); // tailrequest

    // send "tail" of all trains, i.e. array of lists of berth-passings
    socket.on("alltailsrequest", function (msg, fn) { // msg; {trainNo: id, maxBerths: max no Of Berths To Send for one train}
        fn(ctsrealtime.getAllTails(msg.maxBerths));
    }); // alltailsrequest

    socket.on("ghostrequest", function (msg, fn) { // msg; { }
        // send data
        fn(ctsrealtime.getGhosts());
    }); //ghostrequest
}); // socket.io

//
// END CLIENT-COMMUNICATION
//

function handleRealtime (socket, cmdArray) {
    if (!socket.joined) {
        socket.emit("help", {"realtime": cmdDictionary.realtime});
        return;
    }
    let toSocketID = socket.room;
    let tmpSocket = io.sockets.connected[toSocketID];
    if (!toSocketID|| !tmpSocket) {
        socket.emit("chat message", "internal error - communications ID not found (socket.room) " + toSocketID);
        return;
    }
    if (tmpSocket.room === "realtime") {
        socket.emit("chat message", "Already processing realtime");
        return;
    }

    if (tmpSocket.mode === "history") { // playBack is ongoing
        socket.emit("chat message", "Cancel ongoing playback/operation first, then issue new realtime command.");
        return;
    }
    if (tmpSocket.mode !== "ready") {
        console.log("received realtime. tmp.socket.mode: " + tmpSocket.mode);
    }

    if (tmpSocket.room && tmpSocket.room !== "realtime") {  // remember: tmpSocket is the socket of the map-client, not current (cmd) client
        tmpSocket.leave(tmpSocket.room);
    }

    tmpSocket.join("realtime");
    tmpSocket.room = "realtime";
    tmpSocket.mode = "realtime";
    socket.to(toSocketID).emit("realtime", "start");
} // handleRealtime ()

//
// BACK END COMMUNICATIONS
// Subscribe to operational data store (i.e Redis) topics

opstore.subscribe("pax");
opstore.subscribe("LineAggregate");
opstore.subscribe("StationAggregate");
opstore.subscribe("OwnModuleAggregate");
opstore.subscribe("Log");
opstore.subscribe("Error");
opstore.subscribe("cts");
opstore.on("error", function (err) {
    console.log("Error " + err);
});

// Start Redis communication
opstore.on("subscribe", function (channel, count) {
    io.emit("chat message", "succesful subscribe to Redis " + channel + "  " + count);
    console.log("succesful subscribe to Redis: " + channel + " " + count);
});

// Handle data from Redis
opstore.on("message", function fNonOpstoreMessage (channel, msg) {
    const msgObject = JSON.parse(msg);
    if (channel === "pax") {
        apcrealtime.parsePassengerData("realtime", channel, msgObject);
    }
    else if (channel === "LineAggregate") {
        apcrealtime.parseSumPerLine("realtime", channel, msgObject);
    }
    else if (channel === "StationAggregate") {
        apcrealtime.parseSumPerStation("realtime", channel, msgObject);
    }
    else if (channel === "OwnModuleAggregate") { // todo: add room to all of these: realtime
        apcrealtime.parseSumPerOwnModule("realtime", channel, msgObject);
    }
    else if (channel === "cts") {
        ctsrealtime.parseAndSendCTS("realtime", channel, msgObject);
    }
    else if (channel === "Log" || channel === "Error") {
        io.emit("Log", channel + ": " + msg)
    }

    // emit all data we get as a separate topic, except for log-data
    if (channel !== "Log") {
        io.emit("data", msg);
    }
});


// todo: REDIS clean up is not working properly, i.e. if web app terminate and restart, the number of redis connections may increase?
process.on('exit', function () {
    console.log('About to exit.');
    //todo: check if subscription is active and if connection is open
    opstore.unsubscribe();
    opstore.end();
});
process.on('SIGINT', function () {
    console.log('Got CTRL-D');
    //todo: check if subscription is active and if connection is open
    opstore.unsubscribe();
    opstore.end();
    process.exit(2);
});
process.on('uncaughtException', function (e) {
    console.log('Uncaught Exception...');
    console.log(e.stack);
    //todo: check if subscription is active and if connection is open
    opstore.unsubscribe();
    opstore.end();
    process.exit(99);
});

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
    const port = parseInt(val, 10);

    if (helpers.MyIsNaN(port)) {
        // named pipe
        return val;
    }

    if (port >= 0) {
        // port number
        return port;
    }

    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    const bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
    const addr = server.address();
    const bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port;
    //debug('Listening on ' + bind);
}
